/*! \mainpage Project Overview
 *
 * \section intro_sec Introduction
 *
 * First of all, thanks for this experience. This was my first time implementing such a system and I must say that it has been a very funny project. Also, it seems to work! :)
 *
 * I took the liberty of generating this documentation using Doxygen, to enable detailed explanation of choices throughout the code, in case they become a necessity.
 * This page should be sufficient for a quick explanation though. 
 * 
 *
 * \section setup_sec Project setup
 *
 * The project is a VS2017 solution without libraries. The only dependency is the STL library.
 * So it should be possible to compile the solution as is, without more configuration.
 *
 * If run immediatly, will be simulated 5 dogs with randomized initial values. Every update step is paused for 0.5 seconds.
 *
 * \section overview_sec Overview
 *
 * The test is structured in a few main sections, explained in the following paragraphs.
 *
 * I tried to take a practical approach implementing what was needed to work, but I tried to implement the system as if it was inside a complete game. 
 * So I created a Game class and a basic game loop. 
 * Every update step, the AIController performs a BT cycle for every dog, saving on the BlackBoard running states if they arises. 
 * The Action nodes implemented (Idle, Play, Eat) return RUNNING until conditions are met, as requested by the test.
 *
 * \subsection subsec1 High level classes
 *
 * The Game class is the highest level one, which encapsulates all the application. It also simulates a complete game, structured with a update loop. 
 * In fact the ownership of the actor data is in this class. At every update, the actor list is passed to the AIController, the same as every other (virtual) subsystem of this game.
 *
 * The AIController class manages all the AI work. It stores the shared instance of the BlackBoard and starts the Behavior Tree update cycle for every actor passed by the Game class.
 * 
 * The BlackBoard class is the storage space for mutable data which the Behavior Tree needs to work. 
 * Every node can store stateful data for a given actor using the NodeActorAIState struct. 
 * At the moment is mainly used to store the running child index for composite nodes, but is ready for more is necessary. 
 * Through this architecture a Flyweight pattern is achieved, with the common data (the tree and their node functionalities) and instance data (the state data for (node, actor) pairs plus the BTState instance) split.
 * 
 * The BTState class instead is a small class to store stateful data at the whole-tree level. It is used to indicate mainly the current Dog instance, but ready for more.
 *
 * The Dog class is self explanatory, stores Dog specific data, such as a name, energy and boredom, plus some setters and getters.
 * Initial values can be randomized if necessary, all settings are in the Constants source file. 
 * Since the compile time is small and I'm forbidden from using external libraries, I haven't implemented a read from file for it.
 *
 * The BaseBTNode class representes both the entire tree and the single node, acting as a base class for the applied (slightly modified) Composite design pattern.
 * The AIController owns a std::unique_ptr to a single instance of this, which acts as the root of the tree.
 * 
 * \subsection subsec2 The Behavior Tree
 *
 * The tree is structured as shown:
 *
 * \image html tree.png
 *
 *
 * Probably there are better ways to build it, I don't know. It was my first time designing with a BT, but it seems to work as intended.
 *
 * Every node has a initialize, process and terminate function. Currently both initialize and terminate are not used by anyone, since most of the state data have to be sourced every cycle.
 * The structure is however ready for more complex trees and other types of nodes.
 * 
 * Following is the class inheritance diagram of the various nodes.
 *
 * \image html nodes_hierarchy.png
 *
 * As shown, the RepeaterUntilFailBTNode node is implemented, but not used in the current tree. 
 * 
 * I could have used it, repeating a sequence of IsHungry -> Eat activity, but frankly the idea of a dog eating until full seems more realistic, instead of a dog that eats only to the smaller hungry threshold!
 *
 *
 * 
 *
 */